# -*- coding: utf-8 -*-
"""Handles loading individual page images from disk.

This module takes a file path, typically pointing to a temporary image file
generated by the `pdf_splitter` module, validates its existence, and loads
it into a PIL (Pillow) Image object for subsequent processing steps like
preprocessing and text extraction. Includes logging for operations and errors.
"""

import os
import sys
import logging
from PIL import Image, UnidentifiedImageError # Pillow components for image handling

# Get a logger instance for this module
logger = logging.getLogger(__name__)

def load_page_image(image_path: str) -> Image.Image | None:
    """Loads a page image from the specified file path into a PIL Image object.

    Verifies that the path points to an existing file, then attempts to open
    and load the image data using Pillow. This function is designed to handle
    image formats supported by Pillow, including the WebP format used by
    the `pdf_splitter`.

    Args:
        image_path: The file path to the image to be loaded (e.g., a
                    temporary .webp file created from a PDF page).

    Returns:
        A PIL `Image.Image` object if the image is loaded successfully.
        Returns `None` implicitly if an exception occurs during loading,
        though specific exceptions are raised first.

    Raises:
        FileNotFoundError: If the `image_path` does not exist or does not
                           point to a regular file.
        UnidentifiedImageError: If Pillow cannot identify the file format or
                                if the image file is corrupted/invalid.
        TypeError: If the input `image_path` is not a string (though type
                   hinting should help prevent this).
        Exception: For other potential OS-level errors during file access
                   (e.g., permission denied) or unexpected Pillow errors.
    """
    # Input type validation (optional, as type hints exist, but can be explicit)
    if not isinstance(image_path, str):
        msg = "Invalid input type for image_path: Expected string."
        logger.error(msg)
        raise TypeError(msg)

    logger.info(f"Attempting to load page image from: {image_path}")

    # Validate if the path exists and is a file
    if not os.path.isfile(image_path):
        error_msg = f"Image file not found or is not a file at path: {image_path}"
        logger.error(error_msg)
        raise FileNotFoundError(error_msg)

    try:
        # Open the image file using Pillow
        img = Image.open(image_path)
        # Load image data into memory immediately to catch decoding errors
        # and ensure the file handle can be released if needed.
        img.load()
        logger.info(f"Successfully loaded image: mode={img.mode}, size={img.size}")
        # Return the loaded PIL Image object
        return img

    except UnidentifiedImageError as e:
        # Handle cases where Pillow cannot identify or decode the image
        error_msg = f"Cannot identify image file. It might be corrupted or an unsupported format: {image_path}."
        # Log the error with traceback for debugging
        logger.error(f"{error_msg} Pillow Error: {e}", exc_info=True)
        # Re-raise the specific error for potential upstream handling
        raise UnidentifiedImageError(error_msg) from e

    except Exception as e:
        # Catch other potential errors (e.g., permissions, OS errors, unexpected Pillow issues)
        error_msg = f"An unexpected error occurred loading image '{image_path}': {e}"
        logger.error(error_msg, exc_info=True) # Log with traceback
        # Re-raise the generic exception, preserving the original cause
        raise Exception(error_msg) from e

# Example usage block (for testing when script is run directly)
if __name__ == "__main__":
    # Configure logging specifically for the test run if needed
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(name)s - %(message)s')
    logger.info("--- Running loader.py directly for testing ---")

    # Setup for test files
    test_image_dir = "temp_test_loader"
    os.makedirs(test_image_dir, exist_ok=True)
    test_image_path = os.path.join(test_image_dir, "test_loader_image.webp")
    invalid_image_path = os.path.join(test_image_dir, "invalid_image.txt")
    non_existent_path = os.path.join(test_image_dir, "non_existent_image.webp")

    try:
        # Create dummy files for testing if they don't exist
        if not os.path.exists(test_image_path):
            logger.info(f"Creating dummy test image: {test_image_path}")
            try:
                dummy_img = Image.new('RGB', (60, 30), color = 'blue')
                dummy_img.save(test_image_path, "webp", lossless=True)
                dummy_img.close()
            except Exception as img_create_err:
                 logger.error(f"Failed to create dummy image: {img_create_err}")
        if not os.path.exists(invalid_image_path):
             try:
                 with open(invalid_image_path, "w") as f:
                     f.write("This is not an image.")
             except Exception as txt_create_err:
                  logger.error(f"Failed to create dummy text file: {txt_create_err}")


        # --- Test Case 1: Load valid image ---
        if os.path.exists(test_image_path):
            logger.info(f"\nTesting loading valid image: {test_image_path}")
            loaded_image = None # Ensure variable exists for finally block
            try:
                loaded_image = load_page_image(test_image_path)
                if loaded_image:
                    logger.info("Test load successful! Image details:")
                    logger.info(f"  Format: {loaded_image.format}, Size: {loaded_image.size}, Mode: {loaded_image.mode}")
                else:
                    # This path shouldn't be reached if exceptions are raised correctly
                    logger.error("Test load failed unexpectedly (returned None).")
            except Exception as e:
                 logger.error(f"Test Error for valid image: {e}", exc_info=True)
            finally:
                 if loaded_image: loaded_image.close()
        else:
             logger.warning(f"Skipping valid image test, file not found: {test_image_path}")


        # --- Test Case 2: Load non-existent file ---
        logger.info(f"\nTesting non-existent file: {non_existent_path}")
        try:
            load_page_image(non_existent_path)
            logger.error("Error: Expected FileNotFoundError but none was raised.")
        except FileNotFoundError:
            logger.info("Successfully caught FileNotFoundError (expected).")
        except Exception as e:
            logger.error(f"Caught unexpected error for non-existent file: {e}", exc_info=True)


        # --- Test Case 3: Load an invalid image file ---
        if os.path.exists(invalid_image_path):
            logger.info(f"\nTesting invalid image file: {invalid_image_path}")
            try:
                load_page_image(invalid_image_path)
                logger.error("Error: Expected UnidentifiedImageError but none was raised.")
            except UnidentifiedImageError:
                logger.info("Successfully caught UnidentifiedImageError (expected).")
            except Exception as e:
                logger.error(f"Caught unexpected error for invalid file: {e}", exc_info=True)
        else:
             logger.warning(f"Skipping invalid image test, file not found: {invalid_image_path}")


    finally:
        # Clean up dummy files and directory
        logger.info("\nCleaning up test files...")
        paths_to_remove = [test_image_path, invalid_image_path]
        files_removed_count = 0
        for p in paths_to_remove:
            if os.path.exists(p):
                try:
                    os.remove(p)
                    logger.info(f"Removed: {p}")
                    files_removed_count +=1
                except OSError as e:
                    logger.warning(f"Error removing {p}: {e}")
        logger.info(f"Attempted removal of {files_removed_count} test files.")
        try:
            # Attempt to remove dir only if it exists and seems empty
            # Note: other files might exist if tests failed mid-creation
            if os.path.exists(test_image_dir) and len(os.listdir(test_image_dir))==0 :
                 os.rmdir(test_image_dir)
                 logger.info(f"Removed test directory: {test_image_dir}")
            elif os.path.exists(test_image_dir):
                 logger.info(f"Test directory not removed (might not be empty): {test_image_dir}")

        except OSError as e:
             logger.warning(f"Could not remove test directory {test_image_dir}: {e}")

    logger.info("--- Loader Test Complete ---")